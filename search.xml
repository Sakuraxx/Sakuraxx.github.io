<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>递归</title>
      <link href="/2019/10/03/di-gui/"/>
      <url>/2019/10/03/di-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治（divide and conquer）的全称为“分而治之”。分治是将原问题划分为若干个规模较小而结构与原问题相同或者相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即得到为原问题的解。</p><p>分治法的三步：</p><ol><li>分解：将原问题分解为若干个和原问题拥有相同或者相似结构的子问题</li><li>解决：递归求解所有子问题。如果存在子问题的规模小到可以直接解决，就直接解决它。</li><li>合并：将子问题的解合并为原问题的解。</li></ol><p>需要注意，分治法分解出的子问题应该是相互独立、没有交叉的。如果存在两个子问题有相交部分，那么不应当使用分治法解决。</p><p>从广义上来讲，分治法分解的子问题个数只要大于0即可。但是从严格的定义上讲，一般把子问题个数为1的情况称为<strong>减治</strong>，而把子问题个数大于的1的情况称为<strong>分治</strong>。</p><p>分治是作为一种算法思想，可以使用递归去实现也可使用非递归实现。</p><p>对n的阶乘求解的过程体现了减治；对Fibonacci数列的求解过程体现了分治思想。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>有一个看似玩笑的对递归的定义：”要理解递归，你要先理解递归，直到你能理解递归“，虽然第一眼看这句话很糊涂，但是学习完递归回过来看这句话确实很有味道。<strong>递归就在于反复调用自身函数，但是每次把问题范围缩小，直到范围缩小到可以直接得到边界数据的结果，然后再在返回的路上求出对应的解</strong>。      </p><p>从这点看，递归很适合用来实现分治思想。    </p><p>递归的逻辑中一般有两个重要概念：</p><ul><li><strong>递归边界</strong></li><li><strong>递归式</strong>（或者成为递归调用）</li></ul><p>递归式是将原问题分解为若干个子问题的手段，而递归边界是分解的尽头。我们需要注意，如果一直使用递归式将问题分解而不给出一个边界阻止，那么程序将会栈溢出。所以，使用递归一定要有递归边界。</p><h3 id="求n的阶乘"><a href="#求n的阶乘" class="headerlink" title="求n的阶乘"></a>求n的阶乘</h3><p>使用递归求n的阶乘（没有详细解释）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*    使用递归求阶乘*/</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">func</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>使用递归求斐波那契数列的第n项</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*    递归求斐波那契数列*/</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">func</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全排列（Full-Permutation）"><a href="#全排列（Full-Permutation）" class="headerlink" title="全排列（Full Permutation）"></a>全排列（Full Permutation）</h3><p>一般把1~n这n个整数按某个顺序摆放的结果称为这n个整数的一个排列，而全排列是指这n个整数能形成的所有排列。例如对1、2、3这三个整数来说，（1,2,3），（1,3,2），（2,1,3），（2,3,1），（3,1,2），（3,2,1）就是1~3的全排列。这个全排列也是按字典序输出的。   </p><p>从递归的角度去思考，如果把问题描述成”输出1~n这n个数的全排列“，那么它就可以被划分成若干个子问题：”输出以1开头的全排列“，”输出以2开头的全排列“，…，”输出以n开头的全排列“。    </p><p>思路：    </p><p>设置一个数组curPer来存放当前的排列；在设定一个散列数组hashTable来标识整数x是否已经在当前排列中（hashTable[x] = true）。    </p><p>按顺序向curPer中填第1位到第n位的数字。假设我们已经填好了curPer[1]~curPer[n-1]，正准备填curPer[index]。我们需要枚举1<del>n，如果当前枚举的数字x不在curPer[1]</del>curPer[n-1]中（hashTable[x] = false），那么就将它填入curPer[index]中，同时将hashTable[x] =  true，然后再去处理curPer的第index+1位（即<u>进行递归</u>）：而当递归完成时，再将hashTable[x]还原为false，以便让curPer[index]填下一个数字。</p><p>我们递归式算是找到了，可以递归的边界是什么呢？显然，当index达到n+1时，说明curPer的第1~n位已经填好了，此时就可以输出数组curPer了，表示生成了一个排列，然后直接return 就可以。     </p><p><strong>需要注意鸭 判断相等不要写错咯！写成=了！</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> curPer<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> hashTable<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">generateCurPer</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若是index为n+1 则说明curPer已经排满</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> curPer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历1~n个整数，判断是否在curPer中，不在则填进curPer中，记得修改hashTable的状态</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hashTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            curPer<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            hashTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token function">generateCurPer</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续添加下一位</span>            hashTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回时 已处理完curPer[index]为i的子问题，还原状态</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token function">generateCurPer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从curPer[1]开始填</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="n皇后"><a href="#n皇后" class="headerlink" title="n皇后"></a>n皇后</h3><p>n皇后是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两两均不在同一行、同一列、同一条对角线上求合法的方案数。    </p><p>对于这个问题，如果采用组合数的方式来枚举每一种情况（即从n^2个位置中选择n个位置），那么将需要Cn^n|n的枚举量，当n=8时就是54 502 232次枚举，如果n更大那数字将会更大。  </p><p>我们可以换个思路，考虑到<strong>每列只能放置一个皇后、每列也只能放置一个皇后，那么我们将n列皇后所在行号依次写出，那么就会是1~n的一个排列</strong>。那我们的问题也可以转换成，<strong>枚举1~n的所有全排列，查看每个排列对应放置方案是否合法</strong>，统计其中合法的方案即可。由于总共有n!种方案，于是8皇后的方案就为8!=40320次，比之前组合数要小很多！</p><p>于是我们可以在前面全排列的基础上求解。由于<strong>当到达递归边界时发生了一个排列</strong>，所以要<strong>在其内部判断是否为合法方案</strong>，即<strong>遍历每两个皇后，判断它们是否在同一条对角线上（列号的绝对值等于行号的绝对值则在同一对角线上）</strong>（在不同行和不同列是显然的），若不是，则累计计数变量count即可。当n=8时，count=9。</p><p>代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> P<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> hashTable<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用全排列方式求解n皇后</span><span class="token keyword">void</span> <span class="token function">nQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//注意不是=是 == </span>    <span class="token punctuation">{</span>        bool validQueue <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历两两皇后之前是否有冲突</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">abs</span><span class="token punctuation">(</span>P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>P<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果在同一条对角线上 列号的绝对值等于行号的绝对值</span>                <span class="token punctuation">{</span>                    validQueue <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不合法 </span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>validQueue<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> x<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            P<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>            hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token function">nQueue</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    n <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token function">nQueue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"count=%d"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上为枚举所有情况，然后判断每一种情况是否合法，这是非常朴素（<strong>暴力</strong>）的。我们其实通过思考发现，有些情况下，当已经放置了一部分皇后时，可能剩余的皇后无论怎么放置否不可能合法，此时就没有必要往下递归，直接返回上一层就可以。    </p><p>一般来说，如果到达递归边界前的某层，由于一些事实导致已经不需要往任何一个子问题递归，就可以直接返回上一层。一般把这种做法称为<strong>回溯法</strong>。</p><p>以下代码采用了回溯的写法，在安排入第index列的皇后x时，先判断该皇后与之前皇后是否产生冲突，如果没有就填入，否则就跳过这个排列。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//回溯法 使用全排列解决n皇后问题</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> P<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> hashTable<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">nQueue_huisu</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//如果可以到达这层 那么就是合法发n皇后</span>    <span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> x<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            bool validQueue <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//标识当前皇后和之前皇后会不会产生冲突</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pre<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> pre<span class="token operator">&lt;</span>index<span class="token punctuation">;</span> pre<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>index<span class="token operator">-</span>pre<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">abs</span><span class="token punctuation">(</span>x <span class="token operator">-</span> P<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//第index列的皇后的行号为x  </span>                <span class="token punctuation">{</span>                    validQueue <span class="token operator">=</span> false<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>validQueue<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                P<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>                hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>                <span class="token function">nQueue_huisu</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    n <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    clock_t start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">nQueue_huisu</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    clock_t end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"count=%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"耗费了 "</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC <span class="token operator">&lt;&lt;</span> <span class="token string">" 秒"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first again</title>
      <link href="/2019/10/03/first-again/"/>
      <url>/2019/10/03/first-again/</url>
      
        <content type="html"><![CDATA[<h1 id="又是一次"><a href="#又是一次" class="headerlink" title="又是一次"></a>又是一次</h1><h2 id="希望这次可以好好的"><a href="#希望这次可以好好的" class="headerlink" title="希望这次可以好好的"></a>希望这次可以好好的</h2><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><h4 id="对的"><a href="#对的" class="headerlink" title="对的"></a>对的</h4><p>你若安好，便是晴天</p><blockquote><p>他们都是对的</p></blockquote><pre><code>#include &lt;iostream&gt;int main(){    cout&lt;&lt;&quot;Hello World!\n&quot;&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二零一七年终总结</title>
      <link href="/2018/01/22/2017-conclusion/"/>
      <url>/2018/01/22/2017-conclusion/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>时间过得很快，终于等到放寒假了，虽然这几个月没有课，天天和放假也没啥区别呢。细数一下，还有5个月就要毕业了吧，大一刚入学的场景却依然清楚地记得，转眼间就成了老学长了呢。闲来无事，随便写写，有感而发，无病呻吟而已。</p><h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><hr><p>回顾我的2017，没做什么事，令我能记得就3件大事吧：</p><ul><li>失恋ing</li><li>ACM退役</li><li>顺利保研</li></ul><p><strong>第一件事</strong>就不想过多回忆了，<strong>2014.12.13 ~ 2017.03.01</strong>，曲终人散。<br><img src="749826.jpg" alt><br>最后引用《我的少女时代》里的一句话吧。</p><blockquote><p>每人都有一颗林真心，遇见是最美好的小幸运，谢谢你出现在我的青春里。</p></blockquote><p><img src="1.jpg" alt><br><strong>第二件事</strong>其实也是黯淡退出吧，大三下开始课程繁忙，也就没怎么训练了，再加上暑假考驾照，于是乎就退役了。回顾三年来，从大一入学时电脑都没怎么碰过的小白，到现在算法也略有所知，也是付出过很大的努力吧，毕竟当年每天刷题，为了一个bug而熬夜到凌晨。最后也算是混了个水水的金牌，奖项不算耀眼。但最重要的是从这段经历中，学到了拼搏、坚持的一种精神，这对以后的研究生涯想必也有很大帮助。<br><img src="2.jpg" alt><br><strong>第三件事</strong>也是意料之中吧，没有什么波折。纠结了很多，虽然<strong>专业第一</strong>，但是最后还是选择保了本校。要问原因，也许是校园情怀，也许是导师人很好，也许是为了方便更早研究，也许就是懒吧。现在尘埃落定，靠人靠天不如靠自己，继续努力吧。<br><img src="3.jpg" alt></p><p>过去的一年，学业未有很大长进，看着同学们整页的4.0绩点，心里倒也没有什么不平衡了。下学期保了研之后选了一门研究生的文本挖掘课，也马马虎虎读了几十篇论文，也算是对自然语言处理和深度学习入了个门，最后的presentation做的还算满意。</p><h1 id="2018"><a href="#2018" class="headerlink" title="2018"></a>2018</h1><hr><p>今年最重要的大事莫过于毕业论文了，因为以后要做的方向是句法分析，所以导师给我的毕业论文安排的就是《基于循环神经网络的成分句法分析》。虽然说是基于ACL2013的一篇论文改编的，但是目前为止，我还没有发现有人做和这个完全一样的。也许最后写的好的话可以直接发paper了。</p><p>但是目前基本的框架还没完全搭建起来吧，代码还不是很熟练，现在只写了一个最基础的动态规划+RNN。最近有如下计划：</p><ul><li>准备试一下动态规划+LSTM。</li><li>然后动态规划扩增一个维度，用来保存左右结点的head结点。</li><li>如果这个写好了，就可以和我github找到的PCFG+CYK代码融合了，准备加上每个结点的POS。</li><li>最后加入预训练词向量应该就基本完成了。</li></ul><p>希望能顺利毕业吧，前一段时间一直对一些实现细节有些困惑，代码还写错了，还以为理论错了。也不知道最后出来的结果会怎么样，希望能不错。</p><p>生活方面，最近半年越来越懒了，极少出门，睡得晚，起的也晚。最近买了把尤克里里，也算是陶冶陶冶情操吧，不至于一直盯着电脑。现在也小有长进，能弹一点点了。</p><p>现在能聊天的人越来越少了，QQ微信放那一天也不一定会有人来找，就算有人也多半是咨询问题的，等一个可以交心的人吧。有时我也想过，我是不是太像中央空调了，对所有人都这么有耐心，到头来却还是一个人，付出那么多最后还是一无所有。<br><img src="4.jpg" alt><br>最后还是祝自己2018年顺利吧，希望毕业顺利，研究生涯小有收获，最后等一个有缘人吧。</p><blockquote><p>我遇见谁，会有怎样的对白。<br>我等的人，她在多远的未来。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
