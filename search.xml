<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>这是测试</title>
      <link href="/2019/10/04/zhe-shi-ce-shi/"/>
      <url>/2019/10/04/zhe-shi-ce-shi/</url>
      
        <content type="html"><![CDATA[<p>这是测试图片</p><p><img src="1.jpg" alt="测试图片"></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 测试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2019/10/03/di-gui/"/>
      <url>/2019/10/03/di-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>分治（divide and conquer）的全称为“分而治之”。分治是将原问题划分为若干个规模较小而结构与原问题相同或者相似的子问题，然后分别解决这些子问题，最后合并子问题的解，即得到为原问题的解。</p><p>分治法的三步：</p><ol><li>分解：将原问题分解为若干个和原问题拥有相同或者相似结构的子问题</li><li>解决：递归求解所有子问题。如果存在子问题的规模小到可以直接解决，就直接解决它。</li><li>合并：将子问题的解合并为原问题的解。</li></ol><p>需要注意，分治法分解出的子问题应该是相互独立、没有交叉的。如果存在两个子问题有相交部分，那么不应当使用分治法解决。</p><p>从广义上来讲，分治法分解的子问题个数只要大于0即可。但是从严格的定义上讲，一般把子问题个数为1的情况称为<strong>减治</strong>，而把子问题个数大于的1的情况称为<strong>分治</strong>。</p><p>分治是作为一种算法思想，可以使用递归去实现也可使用非递归实现。</p><p>对n的阶乘求解的过程体现了减治；对Fibonacci数列的求解过程体现了分治思想。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>有一个看似玩笑的对递归的定义：”要理解递归，你要先理解递归，直到你能理解递归“，虽然第一眼看这句话很糊涂，但是学习完递归回过来看这句话确实很有味道。<strong>递归就在于反复调用自身函数，但是每次把问题范围缩小，直到范围缩小到可以直接得到边界数据的结果，然后再在返回的路上求出对应的解</strong>。      </p><p>从这点看，递归很适合用来实现分治思想。    </p><p>递归的逻辑中一般有两个重要概念：</p><ul><li><strong>递归边界</strong></li><li><strong>递归式</strong>（或者成为递归调用）</li></ul><p>递归式是将原问题分解为若干个子问题的手段，而递归边界是分解的尽头。我们需要注意，如果一直使用递归式将问题分解而不给出一个边界阻止，那么程序将会栈溢出。所以，使用递归一定要有递归边界。</p><h3 id="求n的阶乘"><a href="#求n的阶乘" class="headerlink" title="求n的阶乘"></a>求n的阶乘</h3><p>使用递归求n的阶乘（没有详细解释）</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*    使用递归求阶乘*/</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">func</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>使用递归求斐波那契数列的第n项</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">/*    递归求斐波那契数列*/</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdio></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cstdlib></span></span><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">func</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">func</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全排列（Full-Permutation）"><a href="#全排列（Full-Permutation）" class="headerlink" title="全排列（Full Permutation）"></a>全排列（Full Permutation）</h3><p>一般把1~n这n个整数按某个顺序摆放的结果称为这n个整数的一个排列，而全排列是指这n个整数能形成的所有排列。例如对1、2、3这三个整数来说，（1,2,3），（1,3,2），（2,1,3），（2,3,1），（3,1,2），（3,2,1）就是1~3的全排列。这个全排列也是按字典序输出的。   </p><p>从递归的角度去思考，如果把问题描述成”输出1~n这n个数的全排列“，那么它就可以被划分成若干个子问题：”输出以1开头的全排列“，”输出以2开头的全排列“，…，”输出以n开头的全排列“。    </p><p>思路：    </p><p>设置一个数组curPer来存放当前的排列；在设定一个散列数组hashTable来标识整数x是否已经在当前排列中（hashTable[x] = true）。    </p><p>按顺序向curPer中填第1位到第n位的数字。假设我们已经填好了curPer[1]~curPer[n-1]，正准备填curPer[index]。我们需要枚举1<del>n，如果当前枚举的数字x不在curPer[1]</del>curPer[n-1]中（hashTable[x] = false），那么就将它填入curPer[index]中，同时将hashTable[x] =  true，然后再去处理curPer的第index+1位（即<u>进行递归</u>）：而当递归完成时，再将hashTable[x]还原为false，以便让curPer[index]填下一个数字。</p><p>我们递归式算是找到了，可以递归的边界是什么呢？显然，当index达到n+1时，说明curPer的第1~n位已经填好了，此时就可以输出数组curPer了，表示生成了一个排列，然后直接return 就可以。     </p><p><strong>需要注意鸭 判断相等不要写错咯！写成=了！</strong></p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> curPer<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span> hashTable<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">generateCurPer</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//若是index为n+1 则说明curPer已经排满</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> curPer<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//遍历1~n个整数，判断是否在curPer中，不在则填进curPer中，记得修改hashTable的状态</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hashTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            curPer<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>            hashTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token function">generateCurPer</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//继续添加下一位</span>            hashTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//返回时 已处理完curPer[index]为i的子问题，还原状态</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    n <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    <span class="token function">generateCurPer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从curPer[1]开始填</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="n皇后"><a href="#n皇后" class="headerlink" title="n皇后"></a>n皇后</h3><p>n皇后是指在一个n*n的国际象棋棋盘上放置n个皇后，使得这n个皇后两两均不在同一行、同一列、同一条对角线上求合法的方案数。    </p><p>对于这个问题，如果采用组合数的方式来枚举每一种情况（即从n^2个位置中选择n个位置），那么将需要Cn^n|n的枚举量，当n=8时就是54 502 232次枚举，如果n更大那数字将会更大。  </p><p>我们可以换个思路，考虑到<strong>每列只能放置一个皇后、每列也只能放置一个皇后，那么我们将n列皇后所在行号依次写出，那么就会是1~n的一个排列</strong>。那我们的问题也可以转换成，<strong>枚举1~n的所有全排列，查看每个排列对应放置方案是否合法</strong>，统计其中合法的方案即可。由于总共有n!种方案，于是8皇后的方案就为8!=40320次，比之前组合数要小很多！</p><p>于是我们可以在前面全排列的基础上求解。由于<strong>当到达递归边界时发生了一个排列</strong>，所以要<strong>在其内部判断是否为合法方案</strong>，即<strong>遍历每两个皇后，判断它们是否在同一条对角线上（列号的绝对值等于行号的绝对值则在同一对角线上）</strong>（在不同行和不同列是显然的），若不是，则累计计数变量count即可。当n=8时，count=9。</p><p>代码如下：</p><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> P<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> hashTable<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span><span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//使用全排列方式求解n皇后</span><span class="token keyword">void</span> <span class="token function">nQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//注意不是=是 == </span>    <span class="token punctuation">{</span>        bool validQueue <span class="token operator">=</span> true<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//遍历两两皇后之前是否有冲突</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">abs</span><span class="token punctuation">(</span>P<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>P<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//如果在同一条对角线上 列号的绝对值等于行号的绝对值</span>                <span class="token punctuation">{</span>                    validQueue <span class="token operator">=</span> false<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//不合法 </span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>validQueue<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> x<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            P<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>            hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>            <span class="token function">nQueue</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    n <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token function">nQueue</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"count=%d"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上为枚举所有情况，然后判断每一种情况是否合法，这是非常朴素（<strong>暴力</strong>）的。我们其实通过思考发现，有些情况下，当已经放置了一部分皇后时，可能剩余的皇后无论怎么放置否不可能合法，此时就没有必要往下递归，直接返回上一层就可以。    </p><p>一般来说，如果到达递归边界前的某层，由于一些事实导致已经不需要往任何一个子问题递归，就可以直接返回上一层。一般把这种做法称为<strong>回溯法</strong>。</p><p>以下代码采用了回溯的写法，在安排入第index列的皇后x时，先判断该皇后与之前皇后是否产生冲突，如果没有就填入，否则就跳过这个排列。</p><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//回溯法 使用全排列解决n皇后问题</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;math.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> MAXN <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token keyword">int</span> n<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> P<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> hashTable<span class="token punctuation">[</span>MAXN<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>false<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">nQueue_huisu</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">==</span> n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//如果可以到达这层 那么就是合法发n皇后</span>    <span class="token punctuation">{</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> x<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">==</span> false<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            bool validQueue <span class="token operator">=</span> true<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//标识当前皇后和之前皇后会不会产生冲突</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> pre<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> pre<span class="token operator">&lt;</span>index<span class="token punctuation">;</span> pre<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>index<span class="token operator">-</span>pre<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">abs</span><span class="token punctuation">(</span>x <span class="token operator">-</span> P<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//第index列的皇后的行号为x  </span>                <span class="token punctuation">{</span>                    validQueue <span class="token operator">=</span> false<span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>validQueue<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                P<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>                hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> true<span class="token punctuation">;</span>                <span class="token function">nQueue_huisu</span><span class="token punctuation">(</span>index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                hashTable<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> false<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    n <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    clock_t start <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">nQueue_huisu</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    clock_t end <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"count=%d\n"</span><span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">;</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"耗费了 "</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> CLOCKS_PER_SEC <span class="token operator">&lt;&lt;</span> <span class="token string">" 秒"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first again</title>
      <link href="/2019/10/03/first-again/"/>
      <url>/2019/10/03/first-again/</url>
      
        <content type="html"><![CDATA[<h1 id="又是一次"><a href="#又是一次" class="headerlink" title="又是一次"></a>又是一次</h1><h2 id="希望这次可以好好的"><a href="#希望这次可以好好的" class="headerlink" title="希望这次可以好好的"></a>希望这次可以好好的</h2><h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><h4 id="对的"><a href="#对的" class="headerlink" title="对的"></a>对的</h4><p>你若安好，便是晴天</p><blockquote><p>他们都是对的</p></blockquote><pre><code>#include &lt;iostream&gt;int main(){    cout&lt;&lt;&quot;Hello World!\n&quot;&lt;&lt;endl;    return 0;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
